{"ast":null,"code":"import axios from \"axios\";\nconst api = axios.create({\n  baseURL: \"http://localhost:8080\"\n});\n\n// Attach access token to every request\napi.interceptors.request.use(config => {\n  const accessToken = sessionStorage.getItem(\"accessToken\");\n  if (accessToken) {\n    config.headers[\"Authorization\"] = \"Bearer \" + accessToken;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Response interceptor for refresh logic\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\napi.interceptors.response.use(response => response, async error => {\n  var _error$response;\n  const originalRequest = error.config;\n\n  // Prevent infinite loop\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry && originalRequest.url !== \"/auth/refresh-token\") {\n    originalRequest._retry = true;\n    if (isRefreshing) {\n      return new Promise(function (resolve, reject) {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers[\"Authorization\"] = \"Bearer \" + token;\n        return api(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    isRefreshing = true;\n    const refreshToken = sessionStorage.getItem(\"refreshToken\");\n    try {\n      const res = await api.post(\"/auth/refresh-token\", {\n        refreshToken\n      });\n      const newAccessToken = res.data.accessToken;\n      // Optionally, you may receive a new refresh token too\n      if (res.data.refreshToken) {\n        sessionStorage.setItem(\"refreshToken\", res.data.refreshToken);\n      }\n      sessionStorage.setItem(\"accessToken\", newAccessToken);\n      processQueue(null, newAccessToken);\n      originalRequest.headers[\"Authorization\"] = \"Bearer \" + newAccessToken;\n      return api(originalRequest);\n    } catch (refreshError) {\n      processQueue(refreshError, null);\n      sessionStorage.removeItem(\"accessToken\");\n      sessionStorage.removeItem(\"refreshToken\");\n      window.location.href = \"/login\";\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","interceptors","request","use","config","accessToken","sessionStorage","getItem","headers","error","Promise","reject","isRefreshing","failedQueue","processQueue","token","forEach","prom","resolve","response","_error$response","originalRequest","status","_retry","url","push","then","catch","err","refreshToken","res","post","newAccessToken","data","setItem","refreshError","removeItem","window","location","href"],"sources":["/Users/alokwaigaonkar/health_care/FrontEnd/src/api.js"],"sourcesContent":["import axios from \"axios\";\n\nconst api = axios.create({\n  baseURL: \"http://localhost:8080\",\n});\n\n// Attach access token to every request\napi.interceptors.request.use(\n  (config) => {\n    const accessToken = sessionStorage.getItem(\"accessToken\");\n    if (accessToken) {\n      config.headers[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\n// Response interceptor for refresh logic\nlet isRefreshing = false;\nlet failedQueue = [];\n\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach((prom) => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\napi.interceptors.response.use(\n  (response) => response,\n  async (error) => {\n    const originalRequest = error.config;\n\n    // Prevent infinite loop\n    if (\n      error.response?.status === 401 &&\n      !originalRequest._retry &&\n      originalRequest.url !== \"/auth/refresh-token\"\n    ) {\n      originalRequest._retry = true;\n\n      if (isRefreshing) {\n        return new Promise(function (resolve, reject) {\n          failedQueue.push({ resolve, reject });\n        })\n          .then((token) => {\n            originalRequest.headers[\"Authorization\"] = \"Bearer \" + token;\n            return api(originalRequest);\n          })\n          .catch((err) => Promise.reject(err));\n      }\n\n      isRefreshing = true;\n      const refreshToken = sessionStorage.getItem(\"refreshToken\");\n\n      try {\n        const res = await api.post(\"/auth/refresh-token\", { refreshToken });\n        const newAccessToken = res.data.accessToken;\n        // Optionally, you may receive a new refresh token too\n        if (res.data.refreshToken) {\n          sessionStorage.setItem(\"refreshToken\", res.data.refreshToken);\n        }\n        sessionStorage.setItem(\"accessToken\", newAccessToken);\n\n        processQueue(null, newAccessToken);\n\n        originalRequest.headers[\"Authorization\"] = \"Bearer \" + newAccessToken;\n        return api(originalRequest);\n      } catch (refreshError) {\n        processQueue(refreshError, null);\n        sessionStorage.removeItem(\"accessToken\");\n        sessionStorage.removeItem(\"refreshToken\");\n        window.location.href = \"/login\";\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\nexport default api;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,GAAG,GAAGD,KAAK,CAACE,MAAM,CAAC;EACvBC,OAAO,EAAE;AACX,CAAC,CAAC;;AAEF;AACAF,GAAG,CAACG,YAAY,CAACC,OAAO,CAACC,GAAG,CACzBC,MAAM,IAAK;EACV,MAAMC,WAAW,GAAGC,cAAc,CAACC,OAAO,CAAC,aAAa,CAAC;EACzD,IAAIF,WAAW,EAAE;IACfD,MAAM,CAACI,OAAO,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGH,WAAW;EAC3D;EACA,OAAOD,MAAM;AACf,CAAC,EACAK,KAAK,IAAKC,OAAO,CAACC,MAAM,CAACF,KAAK,CACjC,CAAC;;AAED;AACA,IAAIG,YAAY,GAAG,KAAK;AACxB,IAAIC,WAAW,GAAG,EAAE;AAEpB,MAAMC,YAAY,GAAGA,CAACL,KAAK,EAAEM,KAAK,GAAG,IAAI,KAAK;EAC5CF,WAAW,CAACG,OAAO,CAAEC,IAAI,IAAK;IAC5B,IAAIR,KAAK,EAAE;MACTQ,IAAI,CAACN,MAAM,CAACF,KAAK,CAAC;IACpB,CAAC,MAAM;MACLQ,IAAI,CAACC,OAAO,CAACH,KAAK,CAAC;IACrB;EACF,CAAC,CAAC;EACFF,WAAW,GAAG,EAAE;AAClB,CAAC;AAEDf,GAAG,CAACG,YAAY,CAACkB,QAAQ,CAAChB,GAAG,CAC1BgB,QAAQ,IAAKA,QAAQ,EACtB,MAAOV,KAAK,IAAK;EAAA,IAAAW,eAAA;EACf,MAAMC,eAAe,GAAGZ,KAAK,CAACL,MAAM;;EAEpC;EACA,IACE,EAAAgB,eAAA,GAAAX,KAAK,CAACU,QAAQ,cAAAC,eAAA,uBAAdA,eAAA,CAAgBE,MAAM,MAAK,GAAG,IAC9B,CAACD,eAAe,CAACE,MAAM,IACvBF,eAAe,CAACG,GAAG,KAAK,qBAAqB,EAC7C;IACAH,eAAe,CAACE,MAAM,GAAG,IAAI;IAE7B,IAAIX,YAAY,EAAE;MAChB,OAAO,IAAIF,OAAO,CAAC,UAAUQ,OAAO,EAAEP,MAAM,EAAE;QAC5CE,WAAW,CAACY,IAAI,CAAC;UAAEP,OAAO;UAAEP;QAAO,CAAC,CAAC;MACvC,CAAC,CAAC,CACCe,IAAI,CAAEX,KAAK,IAAK;QACfM,eAAe,CAACb,OAAO,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGO,KAAK;QAC5D,OAAOjB,GAAG,CAACuB,eAAe,CAAC;MAC7B,CAAC,CAAC,CACDM,KAAK,CAAEC,GAAG,IAAKlB,OAAO,CAACC,MAAM,CAACiB,GAAG,CAAC,CAAC;IACxC;IAEAhB,YAAY,GAAG,IAAI;IACnB,MAAMiB,YAAY,GAAGvB,cAAc,CAACC,OAAO,CAAC,cAAc,CAAC;IAE3D,IAAI;MACF,MAAMuB,GAAG,GAAG,MAAMhC,GAAG,CAACiC,IAAI,CAAC,qBAAqB,EAAE;QAAEF;MAAa,CAAC,CAAC;MACnE,MAAMG,cAAc,GAAGF,GAAG,CAACG,IAAI,CAAC5B,WAAW;MAC3C;MACA,IAAIyB,GAAG,CAACG,IAAI,CAACJ,YAAY,EAAE;QACzBvB,cAAc,CAAC4B,OAAO,CAAC,cAAc,EAAEJ,GAAG,CAACG,IAAI,CAACJ,YAAY,CAAC;MAC/D;MACAvB,cAAc,CAAC4B,OAAO,CAAC,aAAa,EAAEF,cAAc,CAAC;MAErDlB,YAAY,CAAC,IAAI,EAAEkB,cAAc,CAAC;MAElCX,eAAe,CAACb,OAAO,CAAC,eAAe,CAAC,GAAG,SAAS,GAAGwB,cAAc;MACrE,OAAOlC,GAAG,CAACuB,eAAe,CAAC;IAC7B,CAAC,CAAC,OAAOc,YAAY,EAAE;MACrBrB,YAAY,CAACqB,YAAY,EAAE,IAAI,CAAC;MAChC7B,cAAc,CAAC8B,UAAU,CAAC,aAAa,CAAC;MACxC9B,cAAc,CAAC8B,UAAU,CAAC,cAAc,CAAC;MACzCC,MAAM,CAACC,QAAQ,CAACC,IAAI,GAAG,QAAQ;MAC/B,OAAO7B,OAAO,CAACC,MAAM,CAACwB,YAAY,CAAC;IACrC,CAAC,SAAS;MACRvB,YAAY,GAAG,KAAK;IACtB;EACF;EAEA,OAAOF,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;AAC9B,CACF,CAAC;AAED,eAAeX,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}